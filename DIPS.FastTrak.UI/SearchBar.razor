@typeparam T where T : ISearchResult

<div class="SearchBar" tabindex="1">
    <input type="text" value="@_value"
           @oninput="HandleInput" @onkeydown="HandleKeyDown" @onkeydown:preventDefault="@preventKey" />
    @if (_value != "")
    {
        <button @onclick="HandleClearClick">
            <svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m4.397 4.554.073-.084a.75.75 0 0 1 .976-.073l.084.073L12 10.939l6.47-6.47a.75.75 0 1 1 1.06 1.061L13.061 12l6.47 6.47a.75.75 0 0 1 .072.976l-.073.084a.75.75 0 0 1-.976.073l-.084-.073L12 13.061l-6.47 6.47a.75.75 0 0 1-1.06-1.061L10.939 12l-6.47-6.47a.75.75 0 0 1-.072-.976l.073-.084-.073.084Z" /></svg>
        </button>
    }
    @if (_isOpen)
    {
        <div @ref="_resultsReference" class="SearchResults">
            @if (_list != null && _list.Count > 0)
            {
                <Virtualize Items="_list">
                    <div class="SearchResult @GetResultClass(context)"
                         @onclick="async () => await HandleResultClick(context)">
                        @ItemTemplate(context)
                    </div>
                </Virtualize>
            }
            else
            {
                <div class="NoResult">
                    no result
                </div>
            }
        </div>
    }
</div>

@code {
    bool _isOpen;

    string _value = "";

    IList<T>? _list;

    ElementReference _resultsReference;

    int? _selectedIndex;

    bool preventKey;

    /// <summary>
    /// 
    /// </summary>
    [Parameter]
    public bool IsOpen { get; set; }

    [Parameter]
    public EventCallback<bool> IsOpenChanged { get; set; }

    [Parameter, EditorRequired]
    public IList<T>? ItemsSource { get; set; }

    [Parameter]
    public RenderFragment<T> ItemTemplate { get; set; } = context => @<span>@context</span>;

    [Parameter]
    public string? Value { get; set; }

    [Parameter]
    public EventCallback<string?> ValueChanged { get; set; }

    [Parameter]
    public EventCallback<string> OnSearch { get; set; }

    [Parameter]
    public EventCallback<T> OnResultClick { get; set; }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        _isOpen = IsOpen;
        _list = ItemsSource;
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        _list = ItemsSource;
    }

    protected async Task SetIsOpenAsync(bool value)
    {
        _isOpen = value;
        await IsOpenChanged.InvokeAsync(_isOpen);
    }

    private string GetResultClass(T item)
    {
        if (ItemsSource?.IndexOf(item) == _selectedIndex) return "Selected";
        return "";
    }

    private async Task HandleClearClick() => await SetValueAsync("");

    private async Task HandleInput(ChangeEventArgs eventArgs)
    {
        _value = eventArgs.Value?.ToString() ?? "";
        await SetValueAsync(_value);
    }

    private async Task HandleResultClick(T result)
    {
        await OnResultClick.InvokeAsync(result);
        _value = "";
        _isOpen = false;
        StateHasChanged();
    }

    private async Task SetValueAsync(string value)
    {
        _value = value;
        await ValueChanged.InvokeAsync(_value);
        await OnSearch.InvokeAsync(_value);
        await SetIsOpenAsync(_value.Length > 0);
        StateHasChanged();
    }

    private async Task HandleKeyDown(KeyboardEventArgs eventArgs)
    {
        preventKey = false;
        if (_list != null)
        {
            switch (eventArgs.Key)
            {
                case "Enter":
                    if (_selectedIndex.HasValue)
                        await HandleResultClick(_list[_selectedIndex.Value]);
                    break;
                case "ArrowDown":
                    _selectedIndex = _selectedIndex.HasValue ? _selectedIndex + 1 : 0;
                    if (_selectedIndex >= _list.Count) _selectedIndex = _list.Count - 1;
                    preventKey = true;
                    await InvokeAsync(StateHasChanged);
                    break;
                case "ArrowUp":
                    _selectedIndex = Math.Max((_selectedIndex ?? _list.Count) - 1, 0);
                    preventKey = true;
                    await InvokeAsync(StateHasChanged);
                    break;
                case "Home":
                    _selectedIndex = 0;
                    await InvokeAsync(StateHasChanged);
                    break;
                case "End":
                    _selectedIndex = _list.Count - 1;
                    await InvokeAsync(StateHasChanged);
                    break;
            }
        }
    }
}